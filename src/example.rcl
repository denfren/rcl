{
  tags = {
    for host in var.hosts:
    if !var.excluded_devices.contains(host):
    let device_tags = var.device_tags.get(host, []);
    let group_tags = {
      for group, tags in var.group_tags:
      if var.group_devices.get(group, {}).contains(host):
      for tag in tags:
      tag
    };
    host: group_tags | device_tags
  };
}

// Note, we can write record fields in two ways: With `:` or with `=`. In the
// former case, both sides are expressions. This means that the keys can be
// determined at runtime, for example in a comprehension. In the latter case,
// the left-hand side must be an identifier, and we save one character on the
// quotes. It also looks a bit less cluttered.
// The following lines are therefore identical.
{ "foo": 32, "bar": "xyz" }
{ foo = 32, bar = "xyz" }
{ foo = 32, "bar": "xyz" }
let key = "foo"; { key: 32, bar = "xyz" }

// TODO: How to terminate lets? let ...  in, or let ...; ?

// Some terminology to decide on:
// - record (more or less implies typed)
// - object (more or less implies typed)
// - dict, dictionary (implies untyped fields)
// - map (implies untyped fields)

// Defining a function.
let concat = (xs, ys) => [for x in xs: x, for y in ys: y];
concat([1, 2, 3], [4, 5, 6])

let fib = x => if x < 2 then 1 else fib(x - 1) + fib(x - 2); fib(100)

// We could support type annotations in let bindings and arguments.
let fib: Int -> Int = (x: Int) => ...;
let concat
  : List a -> List a -> List a
  = (xs, ys)
  => ...;
let concat = (xs: List a, ys: List a) => ...;

// Row types like in PureScript
type S3Bucket = {
  region: String,
  name: String,
};
let countObjects: S3Bucket -> { count: Int | S3Bucket } = ...;

// Type definitions can be recursive.
type Null = Unit;
type Json
  = Unit
  | Int
  | String
  | Map String Json
  | List Json
  ;

let parse_json: String -> Json = builtins.parse_json;

// I want assertions too. Assertions are nice. They can work exactly like let
// bindings, and in fact the same as assertions in Nix.
let fib = x =>
  assert x >= 0;
  if x < 2
    then 1
    else fib(x - 1) + fib(x - 2);

// Should if-then-else be with blocks as in Rust?
// No, curly brackes are already used for object literals.

// How to treat loading json?
// The following would work as long as we don't specify types. We could even
// infer a type for the data.
let data = load("data.json");

// But if we do that, then what is the type of `load`?
let load: String -> Json = builtins.load;

// The above would not work if we expect something more strict. Is it okay to
// only return Json and then return a type error? I think it is, because json
// data could change under our feet, we don't look inside it, or treat it as
// part of the config. Other rcl files on the other hand, they would have a
// definite type. But that is not something we can give a signature for, maybe
// that needs to be a built-in construct. So the following would in fact treat
// the json file as if it were an rcl file.
let data = import "data.json";

// So this may be valid:
type Person = { age: Int, xp: Int, name: String };
let people: List Person = import "data.json";

// But this would fail to typecheck.
let people: List Person = load("people.json")

// How could we make it typecheck? It would have to be something like
let people: List Person = validate(List Person, load("people.json"))

// but then we are lowering types to the value level ... that opens up an entire
// can of worms. Also how do we import types from other files? If types were
// values then at least that part is clear, although it would also be tedious.
// But maybe? Then it also resolves the syntax difference for generics, we could
// say that types can be called like functions (so we have kinds too).
let PersonList = List(Person);
let rec Json = Map(String, Json) | List(Json) | Int | String | Null;

// But putting that aside for now, a solution that does not open the can of
// worms is to introduce yet another special ad-hoc construct, so that
// syntactically we can *can* mix types and values without them polluting each
// other's namespaces:
let people: List(Person) = load("people.json") as List(Person);
