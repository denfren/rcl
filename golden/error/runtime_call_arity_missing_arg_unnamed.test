// If we define `f` without type annotation, then the inferred type would
// include the argument name. But now we forget the type.
let f: Any = x => x * 2;

// Then here we add the type back. But this time we lost the argument name.
let g: (Any) -> Int = f;

// This assertion would crash the program if we ever got to runtime. But the
// arity error below should be detected at typecheck time already.
// TODO: That is not the case right now, it fails at runtime.
assert false, "This should fail statically before it fails at runtime.";

// Now when we call `g`, we can infer from the type that we are passing too few
// arguments, but we can't name the missing argument.
g()

# output:
stdin:11:8
   ╷
11 │ assert false, "This should fail statically before it fails at runtime.";
   ╵        ^~~~~
Error: Assertion failed. This should fail statically before it fails at runtime.
